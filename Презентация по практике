\documentclass[aspectratio=169]{beamer}
\title{Летняя научно-исследовательская практика}
\author{Выполнили: Попков Дмитрий, Куртев Артем}
\usepackage[main=russian,english]{babel}
\usetheme{Berlin}

\usepackage{listings}



\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Цель работы}
    Цель работы заключается в том, чтобы получить первичные профессиональные умения и навыки, в том числе навыки научно-исследовательской деятельности.
\end{frame}

\begin{frame}{Задачи работы}
    \begin{itemize}
        \item 1. Выбрать одну из задач, представленных в разделе CTF Archive на сайте cryptohack.org и решить ее.
        \item 2. Подготовить презентацию в Beamer.
        \item 3. Подготовить отчет о выполнении практики.
        \item 4. Загрузить все в git-репозиторий
    \end{itemize}
\end{frame}

\begin{frame}{Выполнение работы}
    Нами было выбрано задание под названием Calm Down (HKCERT CTF).
    Текст задания выглядит следующим образом: 
    \begin{figure}
        \centering
        \includegraphics[width=\textwidth]{Text.png}
        \caption{Text}
    \label{}
    \end{figure}
\end{frame}

\begin{frame}{Выполнение работы}
    В файле chall.py находился исходный код оракула, к которому можно было получить доступ через команду nc. Исходный код представлен в git-репозитории по ссылке:https://github.com/Art232/Practica-2023.git.
\end{frame}

\begin{frame}{Выполнение работы}
    В процессе поиска информации о различных атаках на данный алгоритм, а также изучая исходный код, предложенный нам в файле задания, мы обнаружили интересную особенность в реализации алгоритма в наших условиях. При отправке какого-либо сообщения в формате base64, сервер давал ответ, оканчивается ли сообщение точкой или нет. Это подтолкнуло нас на использование атаки, использующей наименьший значащий бит. Иначе говоря, благодаря информации о наличии точки в конце текста можно было дешифровать выданный нам шифротекст. 
\end{frame}

\begin{frame}{Выполнение работы}
    Из открытого ключа необходимо было достать пару чисел, e и n – степень, в которую возвели секретное сообщение и модуль соответственно. Число n было зашифровано в байтовом виде, переведенном в кодировку base64. Число e удалось достать исходя из спецификации реализации алгоритма на сервере. Использовалось стандартное значение e функции RSA.generate(), равное 65537.
\end{frame}

\begin{frame}{Выполнение работы}
    Теперь у нас есть все для того, чтобы иметь возможность повторить зашифрование, ведь $c=m^e\ (mod\ n)$, однако расшифровать мы не сможем, так как не имеем d: $m=c^d\ (mod\ n)$. 
    Умножим наш шифротекст на константу $s^e$. Получим: $s^e c= s^e m^e=(sm)^e\ (mod\ n)$
    Тогда, сервер при расшифровании получит $sm$ вместо оригинального секретного сообщения.
\end{frame}

\begin{frame}{Выполнение работы}
    Следующим шагом обратим внимание на то, что сообщение, в нашем случае флаг, состоящий из порядка 20-30 символов, намного меньше модуля n. Иначе говоря, $m\ (mod\ n)=m$. Установим значение $s$ такое, чтобы $sm$ было чуть больше $n$. Тогда будет выполнится следующее условие: $sm-n>0$. Иначе это можно записать так: $sm=n+r$, и чем ближе к n будет произведение $sm$, тем меньше будет становиться $r$, пока не выяснится, что $sm=n$. Из этой формулы уже можно извлечь секретное сообщение: $m$ = \(\frac{n}{s}\).
\end{frame}

\begin{frame}{Выполнение работы}
    Задача сводится к тому, чтобы найти такое $s$, при котором вышеупомянутая формула будет истинна. В этом нам поможет определение точки в конце текста. Точка в конце кодируется байтом 0x2e. Учитывая, что последний байт $n$ не может быть равен 0x00, так как $n$ – нечетное, а значит необходимо найти такой байт, который при умножении на 0х2е будет выдавать подобное на 0х2е число. Таким байтом является 0х81. Умножив два байта, получим 0x172e. Так, постепенно увеличивая такое число, мы сможем понять, когда мы перешли за границу модуля, ведь точка в конце перестанет быть точкой, а значит сервер сообщит нам об этом. А затем нам достаточно постепенно уменьшить число $s$, чтобы найти то самое наименьшее $s$, чтобы декодировать сообщение.
\end{frame}

\begin{frame}{Выполнение работы}
   На языке программирования Python напишем программу, способную подключиться к нужному нам серверу и имитировать запросы так, как это могли бы делать мы своими руками. Автоматизируем процесс общения с сервером потому, что в ином случае нам вручную пришлось бы перебирать огромное количество входных данных. Помимо того эта же программа будет решать поставленные нами задачи. Код программы представлен в git-репозитории по ссылке: https://github.com/Art232/Practica-2023.git.
\end{frame}

\begin{frame}{Выполнение работы}
    По завершении работы программы получаем следующий флаг:
    Hey, congratulations on solving the challenge. But please hkcert20\{c4lm\_d0wn\_4nd\_s0lv3\_th3\_ch4llen9e\}.
    Введем набор символов, начинающийся с префикса hkcert20 в необходимое поле на сайте cryptohack.org. Появившаяся звезда в левом верхнем углу задания сигнализирует, что секретное сообщение расшифровано верно, а задание выполнено.
\end{frame}

\begin{frame}{Выполнение работы}
   \includegraphics[width=\textwidth]{Success.png}
\end{frame}


\end{document}
